% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
%
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla
% smanjiti
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti master rada Matematičkog fakulteta
\usepackage[latinica,biblatex]{matfmaster}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću:
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% \usepackage{droid}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    citecolor=blue,
}
\usepackage{listings}
\usepackage{listings-rust}
\lstset{
  style=boxed,
  inputpath=../rust_primeri/examples
}
% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Jovan Dmitrović}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Master iz matematike ili računarstva čiji je naslov jako dugačak}
% Godina u kojoj je teza predana komisiji
\godina{2021}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{dr Mika \textsc{Mikić}, redovan profesor\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{dr Ana \textsc{Anić}, vanredni profesor\\ University of Disneyland, Nedođija}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{dr Laza \textsc{Lazić}, docent\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (odkomentarisati narednu liniju i upisati datum odbrane ako je poznat)
% \datumodbrane{}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{Apstrakt ide ovde}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{programiranje, programski jezici}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Mami, tati i dedi}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Uvod}
% ------------------------------------------------------------------------------
\chapter{Programski jezik \emph{Rust}}
\emph{Rust} je statički tipiziran jezik  fokusiran na bezbednost i
performanse. Od svog nastanka, ovaj jezik
je dobio veliku pažnju u svetu programiranja, čemu svedoči i činjenica da je
\emph{Rust} bio proglašen za "omiljeni programski jezik" već petu godinu za redom
u anketi koju je sprovela popularna veb-stranica \emph{Stack Overflow}~\cite{mostloved_so}.

Danas se \emph{Rust} koristi na velikom broju ozbiljnih projekata. Na primer:

\begin{itemize}
    \item AWS servisima firme Amazon, poput \emph{Lambda}, \emph{EC2}
        i \emph{Cloudfront}~\cite{aws},
    \item U okviru operativnog sistema kompanije Gugl (engl. \emph{Google})
        \emph{ChromeOS}~\cite{crosvm},
    \item Određenim komponentama Majkrosoftove platforme \emph{Azure}, uključujući i
        IoT sigurnosni servis \emph{edgelet}~\cite{edgelet},
    \item Registru \emph{JavaScript} paketa \emph{npm},
        kod procedura koje prouzrokuju veliko CPU opterećenje~\cite{npm},
    \item Mozilinom veb-brauzeru Fajerfoks (engl. \emph{Firefox})~\cite{firefox_rust}.
\end{itemize}

\section{Razvoj jezika \emph{Rust}}
Programski jezik \emph{Rust} je dizajnirao Grejdon Hor
(engl. \emph{Graydon Hoare}) koji je, u to vreme, bio zaposlen u kompaniji
Mozila (engl. \emph{Mozilla}).
Hor je rad na ovom jeziku započeo 2006. godine kao svoj lični projekat,
na kojem je samostalno radio naredne tri godine.
Sredinom 2010. godine, u projekat se
uključila i sama Mozila, koja i danas sponzoriše njegov razvoj.
Pored zaposlenih Mozile, pošto je u pitanju programski jezik otvorenog koda,
svoj doprinos je dalo i preko 5000 dobrovoljaca~\cite{thanks_rust}.

Pre nego što se Mozila priključila projektu, \emph{Rust} je izgledao dosta
drugačije nego danas. U svojoj početnoj fazi, \emph{Rust} je bio čist funkcionalni jezik,
tj. nije imao bočne efekte; takođe, postojala je i analiza stanja tipa
(engl. \emph{typestate analysis}), koja je omogućavala proveru operacija
koje se mogu izvoditi nad specifičnim tipom podataka pri kompiliranju. Za
razliku od ove dve osobine, neka dizajnerska rešenja su ostala do danas, kao
što je imutabilnost i kontrola pristupa memoriji.~\cite{history_rust}

Nedugo nakon priključivanja Mozile, Grejdon Hor napušta projekat
2012.\ godine. U ovom periodu \emph{Rust} dobija svoj menadžer
paketa \emph{Cargo} zajedno sa repozitorijumom paketa \url{crates.io}.
Proces \emph{RFC}, inspirisan procesom \emph{PEP} programskog jezika
\emph{Python}~\cite{python_pep}, se
osniva 2014.\ godine u svrhu strogog kontrolisanja novina u samom jeziku.

Prva verzija programskog jezika \emph{Rust}, odnosno \emph{Rust} 1.0, objavljena je 2015.
godine~\cite{stable_rust}. Od tad, u \emph{Rust} zajednici je formiran model izbacivanja novih
verzija gde se one distribuiraju svakih šest nedelja, što je dinamičniji pristup
u odnosu na većinu programskih jezika gde je taj period minimalno godinu dana.
Ovom odlukom se stavlja akcenat na stabilnost jezika time što će svaka nova
verzija biti slična svom prethodniku, dok se kod jezika sa dugim periodom
između verzija očekuju velike promene, što može da šteti kompatibilnosti.

U februaru 2021.\ godine ozvaničen je nastanak \emph{Rust} fondacije (engl.
\texttt{Rust Foundation}), neprofitne organizacije osnovane u svrhe daljeg razvoja programskog
jezika Rust~\cite{rust_foundation}. Pored Mozile, sponzori \emph{Rust} fondacije su i kompanije
\emph{Google}, \emph{AWS}, \emph{Huawei}, \emph{Facebook} i \emph{Microsoft}.

\section{Instalacija i korišćenje sistema \emph{Cargo}}
Ukoliko se zvanična veb-stranica programskog jezika \emph{Rust} poseti koristeći
mašinu koja ima \emph{Windows} operativni sistem, biće ponuđene
instalacione datoteke za 32-bitne i 64-bitne \emph{Windows} sisteme.

Na \emph{GNU/Linux} operativnim sistemima potrebno je uneti sledeću
komandu u terminal:

\begin{lstlisting}[language={}, style=text]
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
\end{lstlisting}

\noindent
Potvrdu da li se instalacija uspešno izvršila može se dobiti proverom verzije
\emph{Rust} kompilatora komandom:

\begin{lstlisting}[language={}, style=text]
rustc --version
\end{lstlisting}

Pored samog \emph{Rust} kompilatora, u instalaciju su uključeni i
sistem \emph{Cargo} i alat \emph{rustup}. Alat \emph{rustup} daje mogućnost
dobavljanja nove verzije \emph{Rust}-a sa veba, kao i
mogućnost deinstalacije komandama:

\begin{lstlisting}[language={}, style=text]
rustup update
rustup self uninstall
\end{lstlisting}

Pored toga što je menadžer paketa, \emph{Cargo} vrši i automatizaciju
prevođenja. Kreiranje novog projekta uz pomoć ovog sistema izvršava
se komandom:

\begin{lstlisting}[language={}, style=text]
cargo new novi_projekat
\end{lstlisting}

Komandom iznad se pravi novi direktorijum \texttt{novi\_projekat} koji
sadrži konfiguracionu datoteku \texttt{Cargo.toml} i direktorijum \texttt{src}
koji treba da sadrži izvorne datoteke obeležene ekstenzijom \emph{.rs}
i u kojem se inicijalno nalazi datoteka \emph{main.rs}. Takođe, sa novim direktorijumom se
inicijalizuje i novi \emph{Git} repozitorijum.

Generisana \texttt{Cargo.toml} datoteka je prikazana na listingu~\ref{inst:cargo}.

\begin{lstlisting}[language=TOML,
                   caption={Inicijalna \emph{Cargo.toml} datoteka}
                   label={inst:cargo}]
[package]
name = "novi_projekat"
version = "0.1.0"
authors = ["jovan <jdmitrovic@gmail.com>"]
edition = "2018"

[dependencies]
\end{lstlisting}

U prvoj liniji koda, \texttt{[package]} označava sekciju koja opisuje
paket koji je napravljen. Informacije koje se ovde nalaze su dobijene
iz varijabli okruženja. Posle oznake \texttt{[dependencies]} se
popisuju svi paketi koji su neophodni za rad sa novim paketom,
tako da ih \emph{Cargo} može dopremiti.

Na listingu~\ref{inst:main} je prikazana \texttt{main.rs} datoteka. U njoj se, po osnovnim
podešavanjima, nalazi \emph{Hello World} program.

\lstinputlisting[language=Rust,
                 caption={Inicijalna \emph{main.rs} datoteka},
                 label={inst:main}]{main.rs}

\emph{Cargo} prevodi projekat komandom
\texttt{cargo build} a prevodi ga i pokreće
\texttt{cargo run}. Korišćenjem komande \texttt{cargo check}
može se proveriti da li se kôd kompilira, bez generisanja
izvršne datoteke, što je korisno jer je ova opcija efikasnija
od korišćenja pomenute \texttt{build} komande. Kompiliranjem
projekta se pravi nova putanja \texttt{target/debug}, gde će se
generisati izvršne datoteke.

Kompilator ima dva profila: \texttt{dev} profil, koji se koristi za prevođenje koda tokom razvoja, i
\texttt{release} profil za prevođenje završne verzije programa, spremne za isporuku. Razlika između
profila ogleda se u nivou optimizacije izvršnog koda: koristeći \texttt{dev} profil, kompilator
će koristiti minimalan nivo optimizacije zarad bržeg prevođenja, dok se za \texttt{release} profil
projekat prevodi sa maksimalnim nivoom optimizacije zarad dobijanja najboljih performansi
programa. Podrazumevano ponašanje je da se koristi \texttt{dev} profil pokretanjem
komande \texttt{cargo build}, dok se prevođenje u \texttt{release} profilu izvršava komandom:

\begin{lstlisting}[language={}, style=text]
cargo build --release
\end{lstlisting}

\section{Osnovne karakteristike jezika}
U nastavku će biti opisane bitne karakteristike programskog jezika \emph{Rust}, koje nisu nužno
u okviru jednog stila programiranja. Zastupljeno je nekoliko programskih paradigmi:

\begin{itemize}
    \item Imperativna,
    \item Objektno-orijentisana, gde se umesto klasa koriste svojstva (engl. \emph{traits}),
    \item Generička, u vidu generičkih tipova,
    \item Funkcionalna, u vidu iteratora i zatvorenja~\cite{functional_rust},
    \item Konkurentna~\cite{concurrent_rust}.
\end{itemize}

\subsection{Promenljive i konstante}
Promenljive se mogu definisati korišćenjem kljucne reči \texttt{let}, čime se podrazumeva da
je takva promenljiva zapravo imutabilna, tj.\ ona se ne može menjati. Imutabilnost
promenljivih omogućava kompilatoru da prepozna razne vrste grešaka već u fazi kompilacije.
Ipak, Rust dozvoljava i definisanje mutabilnih promenljivih korišćenjem ključnih reči \texttt{let mut}.

Pored promenljivih, \emph{Rust} dozvoljava i definisanje konstanti
upotrebom ključne reči \texttt{const}.
Konstante se razlikuju od imutabilnih promeljivih po tome što se
mogu definisati u bilo kom opsegu, uključujući i globalni, i po
tome što konstante samo mogu imati vrednost konstantnog izraza,
ali ne i vrednost izvršavanja funkcije.

U okviru jezika dozvoljeno je i tzv.\ sakrivanje (engl. \emph{shadowing}).
Sakrivanje je ponovno definisanje promenljivih. Za razliku od
korišćenja ključne reči \texttt{mut}, prilikom sakrivanja je
moguće promeniti tip promenljive koja se ponovo definiše.

\subsection{Tipovi}
Programski jezik \emph{Rust} je statički tipiziran jezik, ali
ne zaheva pisanje tipa uz svaku promenljivu, osim ako je to
neophodno; primer je korišćenje funkcije \texttt{parse}:

\lstinputlisting[language=Rust]{parse.rs}

\noindent
Ukoliko se pokuša prevođenje ovog koda, \emph{Cargo} će
pokazati grešku:

\begin{lstlisting}[language={}, style=text]
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let num = "10".parse().expect("Nije unet broj!");
  |         ^^^ consider giving `num` a type
\end{lstlisting}

\noindent
Ova greška se javlja zbog toga što funkcija \texttt{parse}
prima generičke parametre, te je kompilatoru neophodna informacija
kojeg je tipa promenljiva \texttt{num}.

\emph{Rust} sadrži četiri vrste prostih tipova: cele brojeve,
brojeve zapisane u pokretnom zarezu, karaktere i Bulove
konstante \emph{true} i \emph{false}. Celi brojevi mogu biti
označeni ili neoznačeni. Označeni brojevi su predstavljeni
tipovima \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64} i
\texttt{i128}, gde broj posle karaktera \texttt{i} predstavlja
veličinu tipa u bitovima. Neoznačeni brojevi su predstavljeni
analogno označenim, s tim da oni počinju karakterom \texttt{u}.
Postoje i tipovi \texttt{isize} i \texttt{usize} čija veličina
zavisi od arhitekture.
Analogon tipovima \texttt{float} i \texttt{double} iz programskog
jezika \emph{C} su tipovi \texttt{f32} i \texttt{f64}. Tip
\texttt{char} je veličine četiri bajta, gde su karakteri predstavljeni
\emph{Unicode} vrednostima.

Osnovni složeni tipovi u programskom jeziku \emph{Rust} su torke
i nizovi. Torke se predstavljaju navođenjem liste tipova, razdvojene zarazima u okviru
zagrada. Naredni primer ilustruje upotrebu torki:

\lstinputlisting[language=Rust]{tuples_arrays.rs}

Torke mogu sadržati vrednosti različitog tipa, a može im se pristupiti
ili korišćenjem novih promenljivih, ili korišćenjem \texttt{.i} sintakse,
čime se pristupa elementu na $i$-toj poziciji, gde se elementi torke broje
počevši od $0$.

Nizovi predstavljaju kolekciju vrednosti istog tipa i, poput torki,
fiksne su veličine. Obeležavaju se sa uglastim zagradama, unutra kojih su elementi
razdvojeni zarezima.

Niske se u programskom jeziku \emph{Rust} javljaju u dva oblika:
u obliku literala i obliku niske promenljive dužine
(u \emph{Rust}-u se one zovu \emph{string}, odnosno \emph{String}).
Literalima se veličina zna pre kompilacije i njihov sadržaj se ne može promeniti,
pa se one mogu čuvati na steku, dok se niske promenljive dužine moraju čuvati na hipu.

\subsection{Funkcije}
Funkcije se definišu ključnom reči \texttt{fn}, navođenjem imena funkcije za kojim sledi
lista parametara i njihovih tipova u zagradama, razdvojenih zarezima. Nakon liste parametara,
moguće je napisati tip povratne vrednosti posle oznake \texttt{->}. Ukoliko povratni tip izostane,
kompilator će ga automatski izvesti. Na kraju se nalazi telo funkcije između vitičastih zagrada.
Primer funkcije koja izračunava zbir kvadrata dva broja je dat u okviru listinga~\ref{fn:zbir_kvadrata}.

\lstinputlisting[language=Rust,
                 caption={Funkcija koja izračunava zbir kvadrata},
                 label={fn:zbir_kvadrata}]{functions.rs}

\noindent
Pored standardnog korišćenja ključne reči \texttt{return} kao oznake za povratnu vrednost funkcije,
funkcija će vratiti vrednost poslednje naredbe koja se ne završava delimiterom.

\subsection{Kontrola toka}
\emph{Rust} podržava klasične načine kontrole toka sa \texttt{if},
\texttt{while} i \texttt{for} komandama. Postoji par dodatnih mogućosti
koje \emph{Rust} takođe nudi:

\begin{itemize}
  \item Ukoliko je potrebno napisati beskonačnu petlju, nije neophodno koristiti
        \texttt{while} naredbu sa uvek tačnim uslovom, već se može koristiti
        ključna reč \texttt{loop}, kao u listingu~\ref{fc:let_for}, gde se
        \emph{loop} koristi u svrhe nalaženja najvećeg zajedničkog delioca
        dva broja,
  \item I \texttt{while} i \texttt{for} se mogu naći u okviru \texttt{let}
        naredbe, s tim da se u telu petlje mora naći \texttt{break} naredba
        uz koju se dopisuje povratna vrednosti kao u primeru~\ref{fc:let_for},
        analogno korišćenju \texttt{return}
        naredbe u funkcijama,
  \item Iteriranje kroz kolekciju pomoću \texttt{for} petlje se može vršiti ili
        preko indeksa trenutnog elementa, ili pomoću \texttt{iter} funkcije.
        Za iteriranje od kraja kolekcije, na \texttt{iter} se nadovezuje
        funkcija \texttt{rev} kao u listingu~\ref{fc:for}.
\end{itemize}

\lstinputlisting[language=Rust,
                 caption={Korišćenje naredbe \emph{loop} i petlje u okviru \emph{let} naredbe},
                 label={fc:let_for}]{let_for.rs}

\lstinputlisting[language=Rust,
                 caption={Korišćenje \texttt{iter} i \texttt{rev} funkcija},
                 label={fc:for}]{control_flow.rs}

\subsection{Vlasništvo}
Koncept \textbf{vlasništva} je novina u odnosu na druge programske jezike. Ova
osobina dozvoljava programskom jeziku \emph{Rust} da funkcioniše bez sakupljača
otpadaka. Za razliku od sakupljača otpadaka, sistem vlasništva ne utiče ni na
koji način na izvršavanje programa, jer se postupanje prema skupu pravila
vlasništva proverava prilikom prevođenja.

Sistem vlasništva se može svesti na tri pravila:

\begin{enumerate}
  \item Svaka vrednost u programskom jeziku \emph{Rust} ima promenljivu koja
        je poseduje.
  \item U jednom trenutku, za svaku vrednost, postoji tačno jedan vlasnik.
  \item Kada promenljiva završi svoj životni vek, tada se vrednost
        koju ta promenljiva poseduje automatski briše iz memorije.
\end{enumerate}

Primer funkcionisanja ovog sistema se može dati uz pomoć pomenutih niski promenljive dužine,
odnosno tipa \texttt{String}: ako se, kao u listingu~\ref{vl:str}, pokuša
ulančavanje pokazivača na istu vrednost, \texttt{Rust} kompilator će prikazati sledeću grešku:

\begin{lstlisting}[language={}, style=text]
error[E0382]: borrow of moved value: `niska1`
 --> src/main.rs:6:32
  |
2 |     let niska1 = String::from("Hello World!");
  |         ------ move occurs because `niska1` has type `String`, which
does not implement the `Copy` trait
3 |     let niska2 = niska1;
  |                  ------ value moved here
...
6 |     println!("Prva niska: {}", niska1);
  |                                ^^^^^^ value borrowed here after move
\end{lstlisting}

Kompilator ukazuje na promenu poseda vrednosti na koju pokazuje \texttt{niska1}, čime promenljiva
\texttt{niska1} gubi mogućnost manipulisanja vrednošću nad kojom je imala vlasništvo, time poštujući
pravilo da vrednost pripada samo jednoj promenljivoj.

\lstinputlisting[language=Rust,
                 caption={Prenos vlasništva između promenljivih},
                 label={vl:str}]{fn_ownership.rs}

Može se uočiti da je kopiranje promenljive \texttt{niska1} plitko. Duboko kopiranje promenljivih
se odvija pomoću metoda \texttt{clone} koja je implementirana za tip \texttt{String}.

% Pomenuti kasnije Traits, i Trait Copy koji omogućava prostim tipovima da automatski koriste clone

Kada se vrednost promenljive šalje kao parametar funkcije, vlasništvo te vrednosti prelazi
u posed te funkcije, odnosno, promenljiva iz pozivaoca se ne može koristiti nakon pozivanja funkcije.
Međutim, pozvana funkcija može \emph{vratiti} vlasništvo nad promenljivom tako što iskoristi tu
promenljivu kao povratnu vrednost: time se vlasništvo te promenljive vraća pozivaocu te funkcije.
Promenljiva koja je vraćena može biti bilo koja promenljiva nad kojom ta funkcija ima vlasništvo,
uključujući i promenljive koje ne potiču odatle (dakle, i sami parametri funkcije).

\subsection{Pozajmljivanje}\label{subsec:pozajmljivanje}
Proces davanja i preuzimanja vlasništva može da bude nepogodan u nekim slučajevima; zbog toga,
postoji i opcija \textbf{pozajmljivanja} (engl. \emph{borrowing}). Pozajmljivanje omogućava
funkcijama da pozajme vrednosti promenljivih, koje se moraju vratiti vlasniku po završetku
izvršavanja te funkcije, što znači da se pozajmljene promenljive mogu kasnije koristiti.
Promenljive se pozajmljuju koristeći simbol \texttt{\&}, što je ilustrovano na
listingu~\ref{poz:imut}, gde će izvršavanje koda ispisati: \texttt{Niska "Hello world"
ima 2 reci}.

\lstinputlisting[language=Rust,
                 caption={Pozajmljivanje vrednosti promenljivih},
                 label={poz:imut}]{immutable_borrow.rs}

Na sličan način se definišu i reference na promenljive. Vrednosti pozajmljenih promenljivih se ne
mogu menjati preko referenci definisanih na ovaj način; u te svrhe
se koriste mutabilne reference koje se obeležavaju sa \texttt{\&mut}. Za razliku od referenci
u drugim programskim jezicima, može postojati samo jedna mutabilna referenca za jednu
promenljivu u istom dosegu u kojem ne sme postojati ni imutabilna referenca te promenljive.

U \emph{Rust}-u je nemoguće napraviti ``zalutalu'' referencu (engl. \emph{dangling reference}),
tj.\ referencu koja referiše na prostor u memoriji koji se već oslobodio. Prilikom prevođenja
koda, kompilator će dati preporuku za korišćenje statičke reference uz pomoć sintakse
\texttt{\&'static}. Ukoliko bi se pokušalo prevođenje koda iz listinga~\ref{poz:dangle},
kompilator ne bi dozvolio prevođenje bez \texttt{static} oznaka. Konvencija je da imena
promenljivih sa statičkim životnim vekom počinju velikim početnim slovom.

\lstinputlisting[language=Rust,
                 caption={Korišćenje promenljivih sa statičkim životnim vekom},
                 label={poz:dangle}]{dangling.rs}

\subsection{Strukture}
Definisanje struktura se vrši na uobičajen način, ali \emph{Rust} nudi mogućnosti koje skraćuju
sintaksu, kao u listingu~\ref{stc:sdef}.

\lstinputlisting[language=Rust,
                 caption={Kreiranje novih struktura},
                 label={stc:sdef}]{structure_def.rs}

Sa listinga~\ref{stc:sdef} se može primetiti kako se uz pomoć oznake \texttt{..} mogu definisati
nove instance strukture gde se imena
polja poklapaju sa imenima parametara funkcije. U istom primeru će instanca \texttt{student2}
imati isto ime kao i instanca \texttt{student1}, ali će polje \texttt{indeks} imati
drugačiju vrednost.

Strukture se mogu i definisati putem torki, s tim da njihova polja neće imati imena, već će
im se pristupati \texttt{.} notacijom. Strukture definisane na ovaj način ne moraju nužno imati
polja, već im se struktura i ponašanje može postaviti putem interfejsa.

Da bi se implementirali metodi u okviru struktura, koristi se ključna reč \texttt{impl} kao u
listingu~\ref{stc:met}.

\lstinputlisting[language=Rust,
                 caption={Definisanje metoda},
                 label={stc:met}]{structure_method.rs}

\noindent
Mogu se implementirati i metodi koji ne uzimaju instancu kao argument; njima se pristupa pomoću
\texttt{::} notacije.

\subsection{Enumeratori}\label{subsec:enum}
Enumeratori u programskom jeziku \emph{Rust} imaju dodatne mogućnosti u odnosu na enumeratore u
drugim programskim jezicima: svaki ``tip'' u enumeratoru može se posmatrati kao torka vrednosti.
Ovime se, na primer, postiže ponašanje enumeratora \texttt{Option} koji premošćava izostanak vrednosti
\texttt{null}. \texttt{Option} je definisan na sledeći način:

\lstinputlisting[language=Rust,
                 caption={Definisanje enumeratora},
                 label={enum:def}]{enum_def.rs}

Ono što \texttt{Option} nudi jeste mogućnost izostanka neke vrednosti, ali da taj izostanak ne
može uticati na integritet programa. Pre nego što se koristi, vrednost tipa \texttt{Option}
se mora otpakovati (engl. \emph{unwrap}), odnosno, mora se utvrditi da li je vrednost generičkog
tipa \texttt{T} izostala. Otpakivanje se vrši \texttt{match} naredbom kao u
listingu~\ref{enum:match}.

\lstinputlisting[language=Rust,
                 caption={Korišćenje \texttt{match} naredbe},
                 label={enum:match}]{enum_match.rs}

Ukoliko se promenljiva ne otpakuje, kompilator će ispisati odgovarajuću grešku. Slično, greška će
se ispisati i kada naredba \texttt{match} ne pokrije sve moguće vrste enumeratora, gde je moguće
koristiti \texttt{\_} notaciju za obeležavanje podrazumevane grane.

\subsection{Strukture podataka promenljivog sadržaja}
Pored torki i nizova, \emph{Rust} ima podršku za strukture podataka kojima se sadržaj
može menjati: to su vektori i heš mape.

\subsubsection{Vektori}
Vektori su predstavljeni tipom \texttt{Vec<T>}, gde je \texttt{T} generički tip
podataka sadržanih
u vektoru. Novi vektor se inicijalizuje funkcijom \texttt{Vec::new} ili korišćenjem
naredbe \texttt{vec!} kao u listingu~\ref{vec:init}. U istom listingu su prikazane funkcije
dodavanja odnosno brisanja elemenata u vektoru: \texttt{push}, odnosno \texttt{remove}.
Poziv funkcije \texttt{remove(i)} briše element koji se nalazi na poziciji $i$ u vektoru.
Da bi elementi vektora mogli menjati njihovu unutrašnju strukturu, mora se
dodati ključna reč \texttt{mut} prilikom inicijalizacije. Vektorima koji su definisani bez te
ključne reči se i dalje mogu dodavati ili brisati elementi, ali naknadne promene tih
elemenata nisu dozvoljene.

Pravila vlasništva su i dalje na snazi, pa se prilikom iteriranja kroz petlju
koriste reference na elemente vektora. Da bi se te reference mogle menjati, prvo
ih je potrebno dereferencirati operatorom \texttt{*}.

\lstinputlisting[language=Rust,
                 caption={Inicijalizacija, dodavanje i brisanje elemenata iz vektora},
                 label={vec:init}]{vector.rs}

Kao i u nizu, u vektoru se moraju naći elementi istog tipa. Međutim, ovo
ograničenje se može prevazići korišćenjem enumeratora, pošto je kompilatoru
neophodno samo da ima informaciju koji se tipovi mogu naći u vektoru da bi se
mogla rezervisati adekvatna količina memorije.

\subsubsection{Heš mape}

Za razliku od vektora, deo standardne biblioteke koja implementira heš mape
se mora ručno uključiti u program naredbom \texttt{use}. Funkcija insert će uneti
odgovarajući par u mapu, ali će postaviti novu vrednost, bez obzira da li se ključ već
nalazi u mapi.

Korišćenjem funkcije \texttt{entry}, može se dobiti enumerator \texttt{Entry} koji ukazuje
da li vrednost za dati ključ postoji u mapi. Ako se na \texttt{Entry} nadoveže funkcija
\texttt{or\_insert}, koja će uneti odgovarajući par u mapu samo ako taj ključ ne postoji u
mapi. Nakon toga, \texttt{or\_insert} će vratiti referencu na par koji je napravljen, ili koji
je nađen u mapi, kao u listingu~\ref{hmap:insert}. U istom listingu se koristi naredba
\texttt{println!} sa argumentom \texttt{\{:?\}}, koja ispisuje odgovarajuće informacije
za debagiranje; u ovom slučaju, biće ispisano \texttt{\{„Pas”: 7, „Macka”: 3\}}.

\lstinputlisting[language=Rust,
                 caption={Inicijalizacija heš mape i korišćenje \texttt{insert} i \texttt{or\_insert} funkcija},
                 label={hmap:insert}]{hash_map.rs}

\subsection{Generički tipovi i interfejsi}
U sekciji~\ref{subsec:enum}, pomenut je enumerator \texttt{Option} koji predstavlja
omotač za vrednosti bilo kog tipa, da bi se izbeglo korišćenje nedostajućih vrednosti.
Da bi se \texttt{Option} mogao koristiti na taj način, moraju se koristiti generički
tipovi, koji se navode između znakova \texttt{<} i \texttt{>}, kao u
definiciji enumeratora \texttt{Option} u listingu~\ref{enum:def}.

Prilikom definisanja metoda u okviru strukture podataka, kada struktura koristi
jedan ili više generičkih tipova, moguće je implementirati metod samo za jedan
tip, kao u listingu~\ref{gen:struct}, gde se rastojanje između tačaka može
izračunati kada su koordinate zapisane u pokretnom zarezu.

\lstinputlisting[language=Rust,
                 caption={Korišćenje generičkog tipa prilikom definisanja strukture},
                 label={gen:struct}]{generic.rs}

Korišćenje generičkih tipova ne prouzrokuje pad performansi, zato što će
se prilikom prevođenja koda izvršiti monomorfizacija. Monomorfizacija
podrazumeva pretvaranje generičkih tipova u konkretne tipove koji se koriste u
programu, time garantujući da će prevedeni kôd biti podjednako efikasan kao
i kôd koji ne koristi generičke tipove.

Interfejsi (engl. \emph{Traits}) predstavljaju način definisanja zajedničkog ponašanja
struktura i enumeratora. U listingu~\ref{gen:trait_def} je definisan novi
interfejs \texttt{Objekat2D} koji obavezuje objekte da sadrže implementaciju
funkcije \texttt{povrsina}.

\lstinputlisting[language=Rust,
                 caption={Definisanje novog interfejsa},
                 label={gen:trait_def}]{trait_def.rs}

U okviru definicije interfejsa se može naći i podrazumevana implementacija metoda.
U tom slučaju se metode ne moraju implementirati za pojedinačne strukture podataka.

Generički tipovi i interfejsi se mogu koristiti zajedno tako da se obezbedi ograničenje
konkretnih tipova koji se koriste u definiciji funkcija ili struktura. U
listingu~\ref{gen:trait_bound} je definisana funkcija koja kao argument uzima samo
tipove koji implementiraju interfejs \texttt{Objekat2D}.

\lstinputlisting[language=Rust,
                 caption={Definisanje funkcije sa ograničenjem generičkih parametara},
                 label={gen:trait_bound}]{trait_bound.rs}

Za definisanje ograničenja generičkih tipova se može koristiti sintaksička pomoć u
vidu ključne reči \texttt{where}. U listingu~\ref{gen:mul_trait_bound} je prepravljena
funkcija iz listinga~\ref{gen:trait_bound} tako da generički tip mora implementirati
interfejs \texttt{Display}, čime se obezbeđuje mogućnost korišćenja parametra funkcije
u okviru naredbe \texttt{println!}. Bitno je napomenuti da se više različitih interfejsa
ograničenja deklariše oznakom \texttt{+}.

\lstinputlisting[language=Rust,
                 caption={Definisanje funkcije sa ograničenjem višestrukih generičkih parametara},
                 label={gen:mul_trait_bound}]{mul_trait_bound.rs}


\subsubsection{Životni vek referenci}
Svaka referenca u programskom jeziku \emph{Rust} ima svoj životni vek, čak iako on nije
eksplicitno naveden. U sekciji~\ref{subsec:pozajmljivanje} su pomenute zalutale reference,
odnosno reference koje referišu na već oslobođeni prostor. U istoj sekciji je predstavljen
i jedan od načina na koji se problem zalutalih referenci može zaobići:
korišćenjem statičkog životnog veka. Drugi način rešavanja ovog problema jeste korišćenjem
eksplicitno navedenih životnih vekova kao u listingu~\ref{life:fn_def_lifespan}.
Životni vekovi referenci se obeležavaju sa apostrofom i identifikatorom životnog veka posle
znaka \texttt{\&} i pre tipa reference. Prilikom definisanja funkcije se navode između
karaktera \texttt{<} i \texttt{>} zajedno sa generičkim tipovima.

\lstinputlisting[language=Rust,
                 caption={Definisanje funkcije čiji parametri imaju ekplicitno navedene životne vekove},
                 label={life:fn_def_lifespan}]{fn_def_lifespan.rs}

Nije uvek neophodno eksplicitno deklarisati sve životne vekove referenci prilikom
definisanja funkcije, zato što
postoje \textbf{pravila elizije životnih vekova} (engl. \emph{lifetime elision rules}).
U pravila elizije se ubrajaju tri
pravila po kojima kompilator automatski određuje životni vek reference:

\begin{enumerate}
  \item Svaki parametar funkcije koji je referenca dobija jedinstveni identifikator
        životnog veka.
  \item Ako postoji samo jedan parametar funkcije sa životnim vekom i povratna vrednost je
        takođe referenca, onda
        će i povratna vrednost imati isti životni vek kao i taj parametar.
  \item Ako postoji više parametara funkcije koji su reference, ali jedan od
        njih je \texttt{\&self} ili \texttt{\&mut self} sa životnim vekom \texttt{'a},
        onda će povratna vrednost, ukoliko je ona referenca, imati životni vek
        \texttt{'a}.
\end{enumerate}

U listingu~\ref{life:fn_def_lifespan} funkcija \texttt{duza\_rec} ima navedene životne
vekove jer kompilator nije u mogućnosti da izvede sve životne vekove samo iz
pravila elizije. Da životni vekovi nisu eksplicitno napisani, oba parametra funkcije
bi imala jedinstveni životni vek, a životni vek povratne vrednosti bi ostao nepoznat
jer se nijedno pravilo elizije ne odnosi na njega.


% ------------------------------------------------------------------------------
\chapter{Razrada}
\label{chp:razrada}

% ------------------------------------------------------------------------------
\chapter{Zaključak}

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
  \textbf{Jovan Dmitrović} (\emph{Gornji Milanovac, 17.11.1995.})
\end{biografija}
% ------------------------------------------------------------------------------

\end{document}
